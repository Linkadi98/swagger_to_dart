// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'open_api_paths.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

OpenApiPath _$OpenApiPathFromJson(Map<String, dynamic> json) {
  return _OpenApiPath.fromJson(json);
}

/// @nodoc
mixin _$OpenApiPath {
  OpenApiPathMethod? get get => throw _privateConstructorUsedError;
  OpenApiPathMethod? get post => throw _privateConstructorUsedError;
  OpenApiPathMethod? get put => throw _privateConstructorUsedError;
  OpenApiPathMethod? get delete => throw _privateConstructorUsedError;
  OpenApiPathMethod? get options => throw _privateConstructorUsedError;
  OpenApiPathMethod? get head => throw _privateConstructorUsedError;
  OpenApiPathMethod? get patch => throw _privateConstructorUsedError;
  OpenApiPathMethod? get trace => throw _privateConstructorUsedError;

  /// Serializes this OpenApiPath to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OpenApiPathCopyWith<OpenApiPath> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiPathCopyWith<$Res> {
  factory $OpenApiPathCopyWith(
          OpenApiPath value, $Res Function(OpenApiPath) then) =
      _$OpenApiPathCopyWithImpl<$Res, OpenApiPath>;
  @useResult
  $Res call(
      {OpenApiPathMethod? get,
      OpenApiPathMethod? post,
      OpenApiPathMethod? put,
      OpenApiPathMethod? delete,
      OpenApiPathMethod? options,
      OpenApiPathMethod? head,
      OpenApiPathMethod? patch,
      OpenApiPathMethod? trace});

  $OpenApiPathMethodCopyWith<$Res>? get get;
  $OpenApiPathMethodCopyWith<$Res>? get post;
  $OpenApiPathMethodCopyWith<$Res>? get put;
  $OpenApiPathMethodCopyWith<$Res>? get delete;
  $OpenApiPathMethodCopyWith<$Res>? get options;
  $OpenApiPathMethodCopyWith<$Res>? get head;
  $OpenApiPathMethodCopyWith<$Res>? get patch;
  $OpenApiPathMethodCopyWith<$Res>? get trace;
}

/// @nodoc
class _$OpenApiPathCopyWithImpl<$Res, $Val extends OpenApiPath>
    implements $OpenApiPathCopyWith<$Res> {
  _$OpenApiPathCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? get = freezed,
    Object? post = freezed,
    Object? put = freezed,
    Object? delete = freezed,
    Object? options = freezed,
    Object? head = freezed,
    Object? patch = freezed,
    Object? trace = freezed,
  }) {
    return _then(_value.copyWith(
      get: freezed == get
          ? _value.get
          : get // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      post: freezed == post
          ? _value.post
          : post // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      put: freezed == put
          ? _value.put
          : put // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      delete: freezed == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      head: freezed == head
          ? _value.head
          : head // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      patch: freezed == patch
          ? _value.patch
          : patch // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      trace: freezed == trace
          ? _value.trace
          : trace // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
    ) as $Val);
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get get {
    if (_value.get == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.get!, (value) {
      return _then(_value.copyWith(get: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get post {
    if (_value.post == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.post!, (value) {
      return _then(_value.copyWith(post: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get put {
    if (_value.put == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.put!, (value) {
      return _then(_value.copyWith(put: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get delete {
    if (_value.delete == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.delete!, (value) {
      return _then(_value.copyWith(delete: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get options {
    if (_value.options == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.options!, (value) {
      return _then(_value.copyWith(options: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get head {
    if (_value.head == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.head!, (value) {
      return _then(_value.copyWith(head: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get patch {
    if (_value.patch == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.patch!, (value) {
      return _then(_value.copyWith(patch: value) as $Val);
    });
  }

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodCopyWith<$Res>? get trace {
    if (_value.trace == null) {
      return null;
    }

    return $OpenApiPathMethodCopyWith<$Res>(_value.trace!, (value) {
      return _then(_value.copyWith(trace: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OpenApiPathImplCopyWith<$Res>
    implements $OpenApiPathCopyWith<$Res> {
  factory _$$OpenApiPathImplCopyWith(
          _$OpenApiPathImpl value, $Res Function(_$OpenApiPathImpl) then) =
      __$$OpenApiPathImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {OpenApiPathMethod? get,
      OpenApiPathMethod? post,
      OpenApiPathMethod? put,
      OpenApiPathMethod? delete,
      OpenApiPathMethod? options,
      OpenApiPathMethod? head,
      OpenApiPathMethod? patch,
      OpenApiPathMethod? trace});

  @override
  $OpenApiPathMethodCopyWith<$Res>? get get;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get post;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get put;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get delete;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get options;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get head;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get patch;
  @override
  $OpenApiPathMethodCopyWith<$Res>? get trace;
}

/// @nodoc
class __$$OpenApiPathImplCopyWithImpl<$Res>
    extends _$OpenApiPathCopyWithImpl<$Res, _$OpenApiPathImpl>
    implements _$$OpenApiPathImplCopyWith<$Res> {
  __$$OpenApiPathImplCopyWithImpl(
      _$OpenApiPathImpl _value, $Res Function(_$OpenApiPathImpl) _then)
      : super(_value, _then);

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? get = freezed,
    Object? post = freezed,
    Object? put = freezed,
    Object? delete = freezed,
    Object? options = freezed,
    Object? head = freezed,
    Object? patch = freezed,
    Object? trace = freezed,
  }) {
    return _then(_$OpenApiPathImpl(
      get: freezed == get
          ? _value.get
          : get // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      post: freezed == post
          ? _value.post
          : post // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      put: freezed == put
          ? _value.put
          : put // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      delete: freezed == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      head: freezed == head
          ? _value.head
          : head // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      patch: freezed == patch
          ? _value.patch
          : patch // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
      trace: freezed == trace
          ? _value.trace
          : trace // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethod?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OpenApiPathImpl extends _OpenApiPath {
  const _$OpenApiPathImpl(
      {this.get,
      this.post,
      this.put,
      this.delete,
      this.options,
      this.head,
      this.patch,
      this.trace})
      : super._();

  factory _$OpenApiPathImpl.fromJson(Map<String, dynamic> json) =>
      _$$OpenApiPathImplFromJson(json);

  @override
  final OpenApiPathMethod? get;
  @override
  final OpenApiPathMethod? post;
  @override
  final OpenApiPathMethod? put;
  @override
  final OpenApiPathMethod? delete;
  @override
  final OpenApiPathMethod? options;
  @override
  final OpenApiPathMethod? head;
  @override
  final OpenApiPathMethod? patch;
  @override
  final OpenApiPathMethod? trace;

  @override
  String toString() {
    return 'OpenApiPath(get: $get, post: $post, put: $put, delete: $delete, options: $options, head: $head, patch: $patch, trace: $trace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenApiPathImpl &&
            (identical(other.get, get) || other.get == get) &&
            (identical(other.post, post) || other.post == post) &&
            (identical(other.put, put) || other.put == put) &&
            (identical(other.delete, delete) || other.delete == delete) &&
            (identical(other.options, options) || other.options == options) &&
            (identical(other.head, head) || other.head == head) &&
            (identical(other.patch, patch) || other.patch == patch) &&
            (identical(other.trace, trace) || other.trace == trace));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, get, post, put, delete, options, head, patch, trace);

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenApiPathImplCopyWith<_$OpenApiPathImpl> get copyWith =>
      __$$OpenApiPathImplCopyWithImpl<_$OpenApiPathImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OpenApiPathImplToJson(
      this,
    );
  }
}

abstract class _OpenApiPath extends OpenApiPath {
  const factory _OpenApiPath(
      {final OpenApiPathMethod? get,
      final OpenApiPathMethod? post,
      final OpenApiPathMethod? put,
      final OpenApiPathMethod? delete,
      final OpenApiPathMethod? options,
      final OpenApiPathMethod? head,
      final OpenApiPathMethod? patch,
      final OpenApiPathMethod? trace}) = _$OpenApiPathImpl;
  const _OpenApiPath._() : super._();

  factory _OpenApiPath.fromJson(Map<String, dynamic> json) =
      _$OpenApiPathImpl.fromJson;

  @override
  OpenApiPathMethod? get get;
  @override
  OpenApiPathMethod? get post;
  @override
  OpenApiPathMethod? get put;
  @override
  OpenApiPathMethod? get delete;
  @override
  OpenApiPathMethod? get options;
  @override
  OpenApiPathMethod? get head;
  @override
  OpenApiPathMethod? get patch;
  @override
  OpenApiPathMethod? get trace;

  /// Create a copy of OpenApiPath
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OpenApiPathImplCopyWith<_$OpenApiPathImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OpenApiPathMethod _$OpenApiPathMethodFromJson(Map<String, dynamic> json) {
  return _OpenApiPathMethod.fromJson(json);
}

/// @nodoc
mixin _$OpenApiPathMethod {
  @JsonKey(name: 'tags')
  List<String> get tags => throw _privateConstructorUsedError;
  @JsonKey(name: 'summary')
  String? get summary => throw _privateConstructorUsedError;
  @JsonKey(name: 'description')
  String? get description => throw _privateConstructorUsedError;
  @JsonKey(name: 'operationId')
  String get operationId => throw _privateConstructorUsedError;
  @JsonKey(name: 'deprecated')
  bool? get deprecated => throw _privateConstructorUsedError;
  @JsonKey(name: 'security')
  List<Map<String, List<dynamic>>>? get security =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'parameters')
  List<OpenApiPathMethodParameter>? get parameters =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'requestBody')
  OpenApiPathMethodRequestBody? get requestBody =>
      throw _privateConstructorUsedError;
  @JsonKey(name: 'responses')
  Map<String, OpenApiPathMethodResponse>? get responses =>
      throw _privateConstructorUsedError;

  /// Serializes this OpenApiPathMethod to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OpenApiPathMethodCopyWith<OpenApiPathMethod> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiPathMethodCopyWith<$Res> {
  factory $OpenApiPathMethodCopyWith(
          OpenApiPathMethod value, $Res Function(OpenApiPathMethod) then) =
      _$OpenApiPathMethodCopyWithImpl<$Res, OpenApiPathMethod>;
  @useResult
  $Res call(
      {@JsonKey(name: 'tags') List<String> tags,
      @JsonKey(name: 'summary') String? summary,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'operationId') String operationId,
      @JsonKey(name: 'deprecated') bool? deprecated,
      @JsonKey(name: 'security') List<Map<String, List<dynamic>>>? security,
      @JsonKey(name: 'parameters') List<OpenApiPathMethodParameter>? parameters,
      @JsonKey(name: 'requestBody') OpenApiPathMethodRequestBody? requestBody,
      @JsonKey(name: 'responses')
      Map<String, OpenApiPathMethodResponse>? responses});

  $OpenApiPathMethodRequestBodyCopyWith<$Res>? get requestBody;
}

/// @nodoc
class _$OpenApiPathMethodCopyWithImpl<$Res, $Val extends OpenApiPathMethod>
    implements $OpenApiPathMethodCopyWith<$Res> {
  _$OpenApiPathMethodCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? summary = freezed,
    Object? description = freezed,
    Object? operationId = null,
    Object? deprecated = freezed,
    Object? security = freezed,
    Object? parameters = freezed,
    Object? requestBody = freezed,
    Object? responses = freezed,
  }) {
    return _then(_value.copyWith(
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      operationId: null == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      security: freezed == security
          ? _value.security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Map<String, List<dynamic>>>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<OpenApiPathMethodParameter>?,
      requestBody: freezed == requestBody
          ? _value.requestBody
          : requestBody // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethodRequestBody?,
      responses: freezed == responses
          ? _value.responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, OpenApiPathMethodResponse>?,
    ) as $Val);
  }

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiPathMethodRequestBodyCopyWith<$Res>? get requestBody {
    if (_value.requestBody == null) {
      return null;
    }

    return $OpenApiPathMethodRequestBodyCopyWith<$Res>(_value.requestBody!,
        (value) {
      return _then(_value.copyWith(requestBody: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OpenApiPathMethodImplCopyWith<$Res>
    implements $OpenApiPathMethodCopyWith<$Res> {
  factory _$$OpenApiPathMethodImplCopyWith(_$OpenApiPathMethodImpl value,
          $Res Function(_$OpenApiPathMethodImpl) then) =
      __$$OpenApiPathMethodImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'tags') List<String> tags,
      @JsonKey(name: 'summary') String? summary,
      @JsonKey(name: 'description') String? description,
      @JsonKey(name: 'operationId') String operationId,
      @JsonKey(name: 'deprecated') bool? deprecated,
      @JsonKey(name: 'security') List<Map<String, List<dynamic>>>? security,
      @JsonKey(name: 'parameters') List<OpenApiPathMethodParameter>? parameters,
      @JsonKey(name: 'requestBody') OpenApiPathMethodRequestBody? requestBody,
      @JsonKey(name: 'responses')
      Map<String, OpenApiPathMethodResponse>? responses});

  @override
  $OpenApiPathMethodRequestBodyCopyWith<$Res>? get requestBody;
}

/// @nodoc
class __$$OpenApiPathMethodImplCopyWithImpl<$Res>
    extends _$OpenApiPathMethodCopyWithImpl<$Res, _$OpenApiPathMethodImpl>
    implements _$$OpenApiPathMethodImplCopyWith<$Res> {
  __$$OpenApiPathMethodImplCopyWithImpl(_$OpenApiPathMethodImpl _value,
      $Res Function(_$OpenApiPathMethodImpl) _then)
      : super(_value, _then);

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = null,
    Object? summary = freezed,
    Object? description = freezed,
    Object? operationId = null,
    Object? deprecated = freezed,
    Object? security = freezed,
    Object? parameters = freezed,
    Object? requestBody = freezed,
    Object? responses = freezed,
  }) {
    return _then(_$OpenApiPathMethodImpl(
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      operationId: null == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      security: freezed == security
          ? _value._security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Map<String, List<dynamic>>>?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<OpenApiPathMethodParameter>?,
      requestBody: freezed == requestBody
          ? _value.requestBody
          : requestBody // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethodRequestBody?,
      responses: freezed == responses
          ? _value._responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, OpenApiPathMethodResponse>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OpenApiPathMethodImpl extends _OpenApiPathMethod {
  const _$OpenApiPathMethodImpl(
      {@JsonKey(name: 'tags') required final List<String> tags,
      @JsonKey(name: 'summary') required this.summary,
      @JsonKey(name: 'description') required this.description,
      @JsonKey(name: 'operationId') required this.operationId,
      @JsonKey(name: 'deprecated') required this.deprecated,
      @JsonKey(name: 'security')
      final List<Map<String, List<dynamic>>>? security,
      @JsonKey(name: 'parameters')
      required final List<OpenApiPathMethodParameter>? parameters,
      @JsonKey(name: 'requestBody') required this.requestBody,
      @JsonKey(name: 'responses')
      required final Map<String, OpenApiPathMethodResponse>? responses})
      : _tags = tags,
        _security = security,
        _parameters = parameters,
        _responses = responses,
        super._();

  factory _$OpenApiPathMethodImpl.fromJson(Map<String, dynamic> json) =>
      _$$OpenApiPathMethodImplFromJson(json);

  final List<String> _tags;
  @override
  @JsonKey(name: 'tags')
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  @JsonKey(name: 'summary')
  final String? summary;
  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'operationId')
  final String operationId;
  @override
  @JsonKey(name: 'deprecated')
  final bool? deprecated;
  final List<Map<String, List<dynamic>>>? _security;
  @override
  @JsonKey(name: 'security')
  List<Map<String, List<dynamic>>>? get security {
    final value = _security;
    if (value == null) return null;
    if (_security is EqualUnmodifiableListView) return _security;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<OpenApiPathMethodParameter>? _parameters;
  @override
  @JsonKey(name: 'parameters')
  List<OpenApiPathMethodParameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: 'requestBody')
  final OpenApiPathMethodRequestBody? requestBody;
  final Map<String, OpenApiPathMethodResponse>? _responses;
  @override
  @JsonKey(name: 'responses')
  Map<String, OpenApiPathMethodResponse>? get responses {
    final value = _responses;
    if (value == null) return null;
    if (_responses is EqualUnmodifiableMapView) return _responses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'OpenApiPathMethod(tags: $tags, summary: $summary, description: $description, operationId: $operationId, deprecated: $deprecated, security: $security, parameters: $parameters, requestBody: $requestBody, responses: $responses)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenApiPathMethodImpl &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.operationId, operationId) ||
                other.operationId == operationId) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            const DeepCollectionEquality().equals(other._security, _security) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.requestBody, requestBody) ||
                other.requestBody == requestBody) &&
            const DeepCollectionEquality()
                .equals(other._responses, _responses));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_tags),
      summary,
      description,
      operationId,
      deprecated,
      const DeepCollectionEquality().hash(_security),
      const DeepCollectionEquality().hash(_parameters),
      requestBody,
      const DeepCollectionEquality().hash(_responses));

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenApiPathMethodImplCopyWith<_$OpenApiPathMethodImpl> get copyWith =>
      __$$OpenApiPathMethodImplCopyWithImpl<_$OpenApiPathMethodImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OpenApiPathMethodImplToJson(
      this,
    );
  }
}

abstract class _OpenApiPathMethod extends OpenApiPathMethod {
  const factory _OpenApiPathMethod(
          {@JsonKey(name: 'tags') required final List<String> tags,
          @JsonKey(name: 'summary') required final String? summary,
          @JsonKey(name: 'description') required final String? description,
          @JsonKey(name: 'operationId') required final String operationId,
          @JsonKey(name: 'deprecated') required final bool? deprecated,
          @JsonKey(name: 'security')
          final List<Map<String, List<dynamic>>>? security,
          @JsonKey(name: 'parameters')
          required final List<OpenApiPathMethodParameter>? parameters,
          @JsonKey(name: 'requestBody')
          required final OpenApiPathMethodRequestBody? requestBody,
          @JsonKey(name: 'responses')
          required final Map<String, OpenApiPathMethodResponse>? responses}) =
      _$OpenApiPathMethodImpl;
  const _OpenApiPathMethod._() : super._();

  factory _OpenApiPathMethod.fromJson(Map<String, dynamic> json) =
      _$OpenApiPathMethodImpl.fromJson;

  @override
  @JsonKey(name: 'tags')
  List<String> get tags;
  @override
  @JsonKey(name: 'summary')
  String? get summary;
  @override
  @JsonKey(name: 'description')
  String? get description;
  @override
  @JsonKey(name: 'operationId')
  String get operationId;
  @override
  @JsonKey(name: 'deprecated')
  bool? get deprecated;
  @override
  @JsonKey(name: 'security')
  List<Map<String, List<dynamic>>>? get security;
  @override
  @JsonKey(name: 'parameters')
  List<OpenApiPathMethodParameter>? get parameters;
  @override
  @JsonKey(name: 'requestBody')
  OpenApiPathMethodRequestBody? get requestBody;
  @override
  @JsonKey(name: 'responses')
  Map<String, OpenApiPathMethodResponse>? get responses;

  /// Create a copy of OpenApiPathMethod
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OpenApiPathMethodImplCopyWith<_$OpenApiPathMethodImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OpenApiPathMethodParameter _$OpenApiPathMethodParameterFromJson(
    Map<String, dynamic> json) {
  return _OpenApiPathMethodParameter.fromJson(json);
}

/// @nodoc
mixin _$OpenApiPathMethodParameter {
  @JsonKey(name: 'name')
  String get name => throw _privateConstructorUsedError;
  @JsonKey(name: 'in')
  OpenApiPathMethodParameterType get in_ => throw _privateConstructorUsedError;
  @JsonKey(name: 'required')
  bool get required_ => throw _privateConstructorUsedError;
  @OpenApiSchemaJsonConverter()
  @JsonKey(name: 'schema')
  OpenApiSchema get schema => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get example => throw _privateConstructorUsedError;

  /// Serializes this OpenApiPathMethodParameter to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OpenApiPathMethodParameterCopyWith<OpenApiPathMethodParameter>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiPathMethodParameterCopyWith<$Res> {
  factory $OpenApiPathMethodParameterCopyWith(OpenApiPathMethodParameter value,
          $Res Function(OpenApiPathMethodParameter) then) =
      _$OpenApiPathMethodParameterCopyWithImpl<$Res,
          OpenApiPathMethodParameter>;
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String name,
      @JsonKey(name: 'in') OpenApiPathMethodParameterType in_,
      @JsonKey(name: 'required') bool required_,
      @OpenApiSchemaJsonConverter()
      @JsonKey(name: 'schema')
      OpenApiSchema schema,
      String? description,
      String? example});

  $OpenApiSchemaCopyWith<$Res> get schema;
}

/// @nodoc
class _$OpenApiPathMethodParameterCopyWithImpl<$Res,
        $Val extends OpenApiPathMethodParameter>
    implements $OpenApiPathMethodParameterCopyWith<$Res> {
  _$OpenApiPathMethodParameterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? in_ = null,
    Object? required_ = null,
    Object? schema = null,
    Object? description = freezed,
    Object? example = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      in_: null == in_
          ? _value.in_
          : in_ // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethodParameterType,
      required_: null == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as bool,
      schema: null == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as OpenApiSchema,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiSchemaCopyWith<$Res> get schema {
    return $OpenApiSchemaCopyWith<$Res>(_value.schema, (value) {
      return _then(_value.copyWith(schema: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OpenApiPathMethodParameterImplCopyWith<$Res>
    implements $OpenApiPathMethodParameterCopyWith<$Res> {
  factory _$$OpenApiPathMethodParameterImplCopyWith(
          _$OpenApiPathMethodParameterImpl value,
          $Res Function(_$OpenApiPathMethodParameterImpl) then) =
      __$$OpenApiPathMethodParameterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'name') String name,
      @JsonKey(name: 'in') OpenApiPathMethodParameterType in_,
      @JsonKey(name: 'required') bool required_,
      @OpenApiSchemaJsonConverter()
      @JsonKey(name: 'schema')
      OpenApiSchema schema,
      String? description,
      String? example});

  @override
  $OpenApiSchemaCopyWith<$Res> get schema;
}

/// @nodoc
class __$$OpenApiPathMethodParameterImplCopyWithImpl<$Res>
    extends _$OpenApiPathMethodParameterCopyWithImpl<$Res,
        _$OpenApiPathMethodParameterImpl>
    implements _$$OpenApiPathMethodParameterImplCopyWith<$Res> {
  __$$OpenApiPathMethodParameterImplCopyWithImpl(
      _$OpenApiPathMethodParameterImpl _value,
      $Res Function(_$OpenApiPathMethodParameterImpl) _then)
      : super(_value, _then);

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? in_ = null,
    Object? required_ = null,
    Object? schema = null,
    Object? description = freezed,
    Object? example = freezed,
  }) {
    return _then(_$OpenApiPathMethodParameterImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      in_: null == in_
          ? _value.in_
          : in_ // ignore: cast_nullable_to_non_nullable
              as OpenApiPathMethodParameterType,
      required_: null == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as bool,
      schema: null == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as OpenApiSchema,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OpenApiPathMethodParameterImpl extends _OpenApiPathMethodParameter {
  const _$OpenApiPathMethodParameterImpl(
      {@JsonKey(name: 'name') required this.name,
      @JsonKey(name: 'in') required this.in_,
      @JsonKey(name: 'required') required this.required_,
      @OpenApiSchemaJsonConverter()
      @JsonKey(name: 'schema')
      required this.schema,
      this.description,
      this.example})
      : super._();

  factory _$OpenApiPathMethodParameterImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$OpenApiPathMethodParameterImplFromJson(json);

  @override
  @JsonKey(name: 'name')
  final String name;
  @override
  @JsonKey(name: 'in')
  final OpenApiPathMethodParameterType in_;
  @override
  @JsonKey(name: 'required')
  final bool required_;
  @override
  @OpenApiSchemaJsonConverter()
  @JsonKey(name: 'schema')
  final OpenApiSchema schema;
  @override
  final String? description;
  @override
  final String? example;

  @override
  String toString() {
    return 'OpenApiPathMethodParameter(name: $name, in_: $in_, required_: $required_, schema: $schema, description: $description, example: $example)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenApiPathMethodParameterImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.in_, in_) || other.in_ == in_) &&
            (identical(other.required_, required_) ||
                other.required_ == required_) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.example, example) || other.example == example));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, in_, required_, schema, description, example);

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenApiPathMethodParameterImplCopyWith<_$OpenApiPathMethodParameterImpl>
      get copyWith => __$$OpenApiPathMethodParameterImplCopyWithImpl<
          _$OpenApiPathMethodParameterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OpenApiPathMethodParameterImplToJson(
      this,
    );
  }
}

abstract class _OpenApiPathMethodParameter extends OpenApiPathMethodParameter {
  const factory _OpenApiPathMethodParameter(
      {@JsonKey(name: 'name') required final String name,
      @JsonKey(name: 'in') required final OpenApiPathMethodParameterType in_,
      @JsonKey(name: 'required') required final bool required_,
      @OpenApiSchemaJsonConverter()
      @JsonKey(name: 'schema')
      required final OpenApiSchema schema,
      final String? description,
      final String? example}) = _$OpenApiPathMethodParameterImpl;
  const _OpenApiPathMethodParameter._() : super._();

  factory _OpenApiPathMethodParameter.fromJson(Map<String, dynamic> json) =
      _$OpenApiPathMethodParameterImpl.fromJson;

  @override
  @JsonKey(name: 'name')
  String get name;
  @override
  @JsonKey(name: 'in')
  OpenApiPathMethodParameterType get in_;
  @override
  @JsonKey(name: 'required')
  bool get required_;
  @override
  @OpenApiSchemaJsonConverter()
  @JsonKey(name: 'schema')
  OpenApiSchema get schema;
  @override
  String? get description;
  @override
  String? get example;

  /// Create a copy of OpenApiPathMethodParameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OpenApiPathMethodParameterImplCopyWith<_$OpenApiPathMethodParameterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

OpenApiPathMethodResponse _$OpenApiPathMethodResponseFromJson(
    Map<String, dynamic> json) {
  return _OpenApiPathMethodResponse.fromJson(json);
}

/// @nodoc
mixin _$OpenApiPathMethodResponse {
  @JsonKey(name: 'description')
  String? get description => throw _privateConstructorUsedError;
  @JsonKey(name: 'content')
  OpenApiContent get content => throw _privateConstructorUsedError;

  /// Serializes this OpenApiPathMethodResponse to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OpenApiPathMethodResponseCopyWith<OpenApiPathMethodResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiPathMethodResponseCopyWith<$Res> {
  factory $OpenApiPathMethodResponseCopyWith(OpenApiPathMethodResponse value,
          $Res Function(OpenApiPathMethodResponse) then) =
      _$OpenApiPathMethodResponseCopyWithImpl<$Res, OpenApiPathMethodResponse>;
  @useResult
  $Res call(
      {@JsonKey(name: 'description') String? description,
      @JsonKey(name: 'content') OpenApiContent content});

  $OpenApiContentCopyWith<$Res> get content;
}

/// @nodoc
class _$OpenApiPathMethodResponseCopyWithImpl<$Res,
        $Val extends OpenApiPathMethodResponse>
    implements $OpenApiPathMethodResponseCopyWith<$Res> {
  _$OpenApiPathMethodResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? content = null,
  }) {
    return _then(_value.copyWith(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as OpenApiContent,
    ) as $Val);
  }

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiContentCopyWith<$Res> get content {
    return $OpenApiContentCopyWith<$Res>(_value.content, (value) {
      return _then(_value.copyWith(content: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OpenApiPathMethodResponseImplCopyWith<$Res>
    implements $OpenApiPathMethodResponseCopyWith<$Res> {
  factory _$$OpenApiPathMethodResponseImplCopyWith(
          _$OpenApiPathMethodResponseImpl value,
          $Res Function(_$OpenApiPathMethodResponseImpl) then) =
      __$$OpenApiPathMethodResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'description') String? description,
      @JsonKey(name: 'content') OpenApiContent content});

  @override
  $OpenApiContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$OpenApiPathMethodResponseImplCopyWithImpl<$Res>
    extends _$OpenApiPathMethodResponseCopyWithImpl<$Res,
        _$OpenApiPathMethodResponseImpl>
    implements _$$OpenApiPathMethodResponseImplCopyWith<$Res> {
  __$$OpenApiPathMethodResponseImplCopyWithImpl(
      _$OpenApiPathMethodResponseImpl _value,
      $Res Function(_$OpenApiPathMethodResponseImpl) _then)
      : super(_value, _then);

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? content = null,
  }) {
    return _then(_$OpenApiPathMethodResponseImpl(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as OpenApiContent,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OpenApiPathMethodResponseImpl implements _OpenApiPathMethodResponse {
  _$OpenApiPathMethodResponseImpl(
      {@JsonKey(name: 'description') this.description,
      @JsonKey(name: 'content') required this.content});

  factory _$OpenApiPathMethodResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$OpenApiPathMethodResponseImplFromJson(json);

  @override
  @JsonKey(name: 'description')
  final String? description;
  @override
  @JsonKey(name: 'content')
  final OpenApiContent content;

  @override
  String toString() {
    return 'OpenApiPathMethodResponse(description: $description, content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenApiPathMethodResponseImpl &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, description, content);

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenApiPathMethodResponseImplCopyWith<_$OpenApiPathMethodResponseImpl>
      get copyWith => __$$OpenApiPathMethodResponseImplCopyWithImpl<
          _$OpenApiPathMethodResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OpenApiPathMethodResponseImplToJson(
      this,
    );
  }
}

abstract class _OpenApiPathMethodResponse implements OpenApiPathMethodResponse {
  factory _OpenApiPathMethodResponse(
          {@JsonKey(name: 'description') final String? description,
          @JsonKey(name: 'content') required final OpenApiContent content}) =
      _$OpenApiPathMethodResponseImpl;

  factory _OpenApiPathMethodResponse.fromJson(Map<String, dynamic> json) =
      _$OpenApiPathMethodResponseImpl.fromJson;

  @override
  @JsonKey(name: 'description')
  String? get description;
  @override
  @JsonKey(name: 'content')
  OpenApiContent get content;

  /// Create a copy of OpenApiPathMethodResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OpenApiPathMethodResponseImplCopyWith<_$OpenApiPathMethodResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

OpenApiPathMethodRequestBody _$OpenApiPathMethodRequestBodyFromJson(
    Map<String, dynamic> json) {
  return _OpenApiPathMethodRequestBody.fromJson(json);
}

/// @nodoc
mixin _$OpenApiPathMethodRequestBody {
  @JsonKey(name: 'required')
  bool? get required_ => throw _privateConstructorUsedError;
  @JsonKey(name: 'content')
  OpenApiContent get content => throw _privateConstructorUsedError;

  /// Serializes this OpenApiPathMethodRequestBody to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OpenApiPathMethodRequestBodyCopyWith<OpenApiPathMethodRequestBody>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiPathMethodRequestBodyCopyWith<$Res> {
  factory $OpenApiPathMethodRequestBodyCopyWith(
          OpenApiPathMethodRequestBody value,
          $Res Function(OpenApiPathMethodRequestBody) then) =
      _$OpenApiPathMethodRequestBodyCopyWithImpl<$Res,
          OpenApiPathMethodRequestBody>;
  @useResult
  $Res call(
      {@JsonKey(name: 'required') bool? required_,
      @JsonKey(name: 'content') OpenApiContent content});

  $OpenApiContentCopyWith<$Res> get content;
}

/// @nodoc
class _$OpenApiPathMethodRequestBodyCopyWithImpl<$Res,
        $Val extends OpenApiPathMethodRequestBody>
    implements $OpenApiPathMethodRequestBodyCopyWith<$Res> {
  _$OpenApiPathMethodRequestBodyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? required_ = freezed,
    Object? content = null,
  }) {
    return _then(_value.copyWith(
      required_: freezed == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as bool?,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as OpenApiContent,
    ) as $Val);
  }

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OpenApiContentCopyWith<$Res> get content {
    return $OpenApiContentCopyWith<$Res>(_value.content, (value) {
      return _then(_value.copyWith(content: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OpenApiPathMethodRequestBodyImplCopyWith<$Res>
    implements $OpenApiPathMethodRequestBodyCopyWith<$Res> {
  factory _$$OpenApiPathMethodRequestBodyImplCopyWith(
          _$OpenApiPathMethodRequestBodyImpl value,
          $Res Function(_$OpenApiPathMethodRequestBodyImpl) then) =
      __$$OpenApiPathMethodRequestBodyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'required') bool? required_,
      @JsonKey(name: 'content') OpenApiContent content});

  @override
  $OpenApiContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$OpenApiPathMethodRequestBodyImplCopyWithImpl<$Res>
    extends _$OpenApiPathMethodRequestBodyCopyWithImpl<$Res,
        _$OpenApiPathMethodRequestBodyImpl>
    implements _$$OpenApiPathMethodRequestBodyImplCopyWith<$Res> {
  __$$OpenApiPathMethodRequestBodyImplCopyWithImpl(
      _$OpenApiPathMethodRequestBodyImpl _value,
      $Res Function(_$OpenApiPathMethodRequestBodyImpl) _then)
      : super(_value, _then);

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? required_ = freezed,
    Object? content = null,
  }) {
    return _then(_$OpenApiPathMethodRequestBodyImpl(
      required_: freezed == required_
          ? _value.required_
          : required_ // ignore: cast_nullable_to_non_nullable
              as bool?,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as OpenApiContent,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OpenApiPathMethodRequestBodyImpl
    implements _OpenApiPathMethodRequestBody {
  _$OpenApiPathMethodRequestBodyImpl(
      {@JsonKey(name: 'required') this.required_,
      @JsonKey(name: 'content') required this.content});

  factory _$OpenApiPathMethodRequestBodyImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$OpenApiPathMethodRequestBodyImplFromJson(json);

  @override
  @JsonKey(name: 'required')
  final bool? required_;
  @override
  @JsonKey(name: 'content')
  final OpenApiContent content;

  @override
  String toString() {
    return 'OpenApiPathMethodRequestBody(required_: $required_, content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenApiPathMethodRequestBodyImpl &&
            (identical(other.required_, required_) ||
                other.required_ == required_) &&
            (identical(other.content, content) || other.content == content));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, required_, content);

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenApiPathMethodRequestBodyImplCopyWith<
          _$OpenApiPathMethodRequestBodyImpl>
      get copyWith => __$$OpenApiPathMethodRequestBodyImplCopyWithImpl<
          _$OpenApiPathMethodRequestBodyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OpenApiPathMethodRequestBodyImplToJson(
      this,
    );
  }
}

abstract class _OpenApiPathMethodRequestBody
    implements OpenApiPathMethodRequestBody {
  factory _OpenApiPathMethodRequestBody(
          {@JsonKey(name: 'required') final bool? required_,
          @JsonKey(name: 'content') required final OpenApiContent content}) =
      _$OpenApiPathMethodRequestBodyImpl;

  factory _OpenApiPathMethodRequestBody.fromJson(Map<String, dynamic> json) =
      _$OpenApiPathMethodRequestBodyImpl.fromJson;

  @override
  @JsonKey(name: 'required')
  bool? get required_;
  @override
  @JsonKey(name: 'content')
  OpenApiContent get content;

  /// Create a copy of OpenApiPathMethodRequestBody
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OpenApiPathMethodRequestBodyImplCopyWith<
          _$OpenApiPathMethodRequestBodyImpl>
      get copyWith => throw _privateConstructorUsedError;
}
